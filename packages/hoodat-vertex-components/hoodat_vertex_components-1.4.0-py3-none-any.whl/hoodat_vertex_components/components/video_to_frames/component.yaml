name: Video to frames func
inputs:
- {name: video_bucket, type: String}
- {name: video_type, type: String}
- {name: video_save_name, type: String}
- {name: every_n_frames, type: Integer}
implementation:
  container:
    image: europe-west1-docker.pkg.dev/hoodat-sandbox/hoodat-sandbox-kfp-components/video_to_frames
    command:
    - sh
    - -ec
    - |
      program_path=$(mktemp)
      printf "%s" "$0" > "$program_path"
      python3 -u "$program_path" "$@"
    - |
      def video_to_frames_func(
          video_bucket, video_type, video_save_name, every_n_frames
      ):
          import os
          import cv2
          from math import floor

          # Read the video file
          source = f"/gcs/{video_bucket}/{video_type}/{video_save_name}"
          save_dir_root = f"/gcs/{video_bucket}/frames/{video_type}/{video_save_name}"
          if every_n_frames == 1:
              save_dir = f"{save_dir_root}/clean_complete/"
          elif every_n_frames == 30:
              save_dir = f"{save_dir_root}/clean/"
          else:
              raise
          vidcap = cv2.VideoCapture(source)
          vidcap_metrics = {
              "num_frames": int(vidcap.get(cv2.CAP_PROP_FRAME_COUNT)),
              "width": int(vidcap.get(cv2.CAP_PROP_FRAME_WIDTH)),
              "height": int(vidcap.get(cv2.CAP_PROP_FRAME_HEIGHT)),
              "fps": vidcap.get(cv2.CAP_PROP_FPS),
          }
          print(source)
          print(vidcap_metrics["num_frames"])
          print(vidcap_metrics["width"])
          print(vidcap_metrics["height"])
          print(vidcap_metrics["fps"])
          vidcap_metrics["num_frames_to_save"] = floor(
              float(vidcap_metrics["num_frames"]) / float(every_n_frames)
          )
          print("vidcap_metrics: " + str(vidcap_metrics))
          success, image = vidcap.read()
          print("Success: " + str(success))
          # Initialise the count that will increase with each frame
          count = 0
          # If the video is read successfully
          if success is True:
              save_dir_exists = os.path.isdir(save_dir)
              print("Directory already exists: " + str(save_dir_exists))
              if not save_dir_exists:
                  os.makedirs(save_dir)
              frames_list = os.listdir(save_dir)
              if len(frames_list) == vidcap_metrics["num_frames"]:
                  print("Frames already saved")
                  success = False
              else:
                  print("Saving output to: " + save_dir + "\n")
          while success:
              # Read the next frame
              try:
                  success, image = vidcap.read()
                  # Where to save the frame
                  # if count % int(args.every_n_frames) == 0:
                  if count % every_n_frames == 0:
                      save_path = save_dir + "f" + str(count) + ".jpg"
                      cv2.imwrite(save_path, image)  # save frame as JPEG file
                  # Print progress after every 100th frame
                  # if count % (int(args.every_n_frames) * 100) == 0:
                  if count % (every_n_frames * 100) == 0:
                      print("Saving frame: " + str(count))
                  # Increase count
                  count += 1
              except Exception as e:
                  print("Error in image capture on frame {0}".format(count))
                  print(e)
          num_frames_saved = len(os.listdir(save_dir))
          print("Total frames saved: " + str(num_frames_saved))
          print("Finished getting frames")
          if num_frames_saved == vidcap_metrics["num_frames_to_save"]:
              success = True
          else:
              success = False
          print(f"All frames successfully saved: {success}")
          if not success:
              raise

      import argparse
      _parser = argparse.ArgumentParser(prog='Video to frames func', description='')
      _parser.add_argument("--video-bucket", dest="video_bucket", type=str, required=True, default=argparse.SUPPRESS)
      _parser.add_argument("--video-type", dest="video_type", type=str, required=True, default=argparse.SUPPRESS)
      _parser.add_argument("--video-save-name", dest="video_save_name", type=str, required=True, default=argparse.SUPPRESS)
      _parser.add_argument("--every-n-frames", dest="every_n_frames", type=int, required=True, default=argparse.SUPPRESS)
      _parsed_args = vars(_parser.parse_args())

      _outputs = video_to_frames_func(**_parsed_args)
    args:
    - --video-bucket
    - {inputValue: video_bucket}
    - --video-type
    - {inputValue: video_type}
    - --video-save-name
    - {inputValue: video_save_name}
    - --every-n-frames
    - {inputValue: every_n_frames}
