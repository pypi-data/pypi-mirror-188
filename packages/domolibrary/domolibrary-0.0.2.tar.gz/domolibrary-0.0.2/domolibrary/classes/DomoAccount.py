# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoAccount.ipynb.

# %% auto 0
__all__ = ['DomoAccount_Config_AbstractCredential', 'DomoAccount_Config_DatasetCopy', 'DomoAccount_Config_Governance',
           'DomoAccount_Config_HighBandwidthConnector', 'AccountConfig', 'DomoAccount',
           'DomoAccount_DeleteAccount_Error']

# %% ../../nbs/classes/50_DomoAccount.ipynb 3
from enum import Enum
from dataclasses import dataclass, field
from abc import ABC, abstractclassmethod, abstractmethod

import datetime as dt
import re


import aiohttp

from fastcore.basics import patch_to

import domolibrary.utils.convert as cd
import domolibrary.utils.DictDot as util_dd
import domolibrary.client.DomoAuth as dmda
import domolibrary.routes.account as account_routes

# %% ../../nbs/classes/50_DomoAccount.ipynb 6
@dataclass
class DomoAccount_Config_AbstractCredential(DomoAccount_Config):
    data_provider_type = 'abstract-credential-store'
    credentials: dict

    def __post_init_(self):
        super().__init__(self)

    @classmethod
    def _from_json(cls, obj):

        dd = util_dd.DictDot(obj)

        return cls(
            credentials=dd.credentials,
        )

    def to_json(self):
        return {"credentials": self.credentials}

# %% ../../nbs/classes/50_DomoAccount.ipynb 7
@dataclass
class DomoAccount_Config_DatasetCopy(DomoAccount_Config):
    domo_instance: str
    access_token: str = field(repr=False)

    data_provider_type = 'dataset-copy'
    

    def __post_init_(self):
        super().__init__(self)

    @classmethod
    def _from_json(cls, obj):

        dd = util_dd.DictDot(obj)

        return cls(
            access_token=dd.accessToken,
            domo_instance=dd.instance
        )

    def to_json(self):
        return {"accessToken": self.access_token,
                "instance": self.domo_instance
                }


# %% ../../nbs/classes/50_DomoAccount.ipynb 8
@dataclass
class DomoAccount_Config_Governance(DomoAccount_Config):
    domo_instance: str
    access_token: str = field(repr=False)

    data_provider_type = 'domo-governance-d14c2fef-49a8-4898-8ddd-f64998005600'

    def __post_init_(self):
        super().__init__(self)

    @classmethod
    def _from_json(cls, obj):

        dd = util_dd.DictDot(obj)

        return cls(
            access_token=dd.apikey,
            domo_instance=dd.customer
        )

    def to_json(self):
        return {"apikey": self.access_token,
                "customer": self.domo_instance
                }


# %% ../../nbs/classes/50_DomoAccount.ipynb 9
@dataclass
class DomoAccount_Config_HighBandwidthConnector(DomoAccount_Config):
    aws_access_key: str
    aws_secret_key: str = field(repr=False)
    s3_staging_dir: str
    region: str = "us-west-2"
    
    data_provider_type = "amazon-athena-high-bandwidth"

    def __post_init_(self):
        super().__init__(self)

    @classmethod
    def _from_json(cls, obj):

        dd = util_dd.DictDot(obj)

        return cls(
            aws_access_key=dd.awsAccessKey,
            aws_secret_key=dd.awsSecretKey,
            s3_staging_dir=dd.s3StagingDir,
            region=dd.region,
        )

    def to_json(self):
        return {
            "awsAccessKey": self.aws_access_key,
            "awsSecretKey": self.aws_secret_key,
            "s3StagingDir": self.s3_staging_dir,
            "region": self.region,
        }

# %% ../../nbs/classes/50_DomoAccount.ipynb 10
class AccountConfig(Enum):
    """
    Enum provides appropriate spelling for data_provider_type and config object.  
    The name of the enum should correspond with the data_provider_type with hyphens replaced with underscores.
    """

    amazon_athena_high_bandwidth = DomoAccount_Config_HighBandwidthConnector

    abstract_credential_store = DomoAccount_Config_AbstractCredential

    dataset_copy = DomoAccount_Config_DatasetCopy

    domo_governance_d14c2fef_49a8_4898_8ddd_f64998005600 = DomoAccount_Config_Governance


# %% ../../nbs/classes/50_DomoAccount.ipynb 12
@dataclass
class DomoAccount:
    name: str
    data_provider_type: str

    id: int = None
    created_dt: dt.datetime = None
    modified_dt: dt.datetime = None
    auth: dmda.DomoAuth = field(repr=False, default=None)

    config: DomoAccount_Config = None

    @classmethod
    def _from_json(cls, obj: dict, auth: dmda.DomoAuth = None):
        """converts data_v1_accounts API response into an accounts class object"""

        dd = util_dd.DictDot(obj)

        return cls(
            id=dd.id,
            name=dd.displayName,
            data_provider_type=dd.dataProviderType,
            created_dt=cd.convert_epoch_millisecond_to_datetime(dd.createdAt),
            modified_dt=cd.convert_epoch_millisecond_to_datetime(dd.modifiedAt),
            auth=auth,
        )
    
    async def _get_config(self, session = None, debug_api : bool = None, return_raw: bool = False):
    
        res_config = await account_routes.get_account_config(
            auth=self.auth,
            account_id=self.id,
            data_provider_type=self.data_provider_type,
            session=session,
            debug_api=debug_api
        )

        if return_raw:
            return res_config

        enum_clean = re.sub("-", "_", self.data_provider_type)

        if not enum_clean in AccountConfig.__members__:
            return None

        self.config = (
            AccountConfig[enum_clean].value._from_json(res_config.response)
        )

        return self.config


# %% ../../nbs/classes/50_DomoAccount.ipynb 25
def DomoAccount_DeleteAccount_Error(Exception):
    def __init__(self, account_id, domo_instance, status, reason) -> bool:
        message = f"DeleteAccount Error :: {account_id} in {domo_instance} :: {status} - {reason}"
        super.__init__(message)


@patch_to(DomoAccount)
async def delete_account(self: DomoAccount,
                         auth: dmda.DomoAuth = None,
                         debug_api: bool = False, session: aiohttp.ClientSession = None):

    auth = auth or self.auth

    res = await account_routes.delete_account(auth=auth,
                                              account_id=self.id,
                                              debug_api=debug_api,
                                              session=session)

    if not res.is_success:
        raise DomoAccount_DeleteAccount_Error(
            account_id = self.id, domo_instance = auth.domo_instance, status = res.status, reason = res.response)

    return True

