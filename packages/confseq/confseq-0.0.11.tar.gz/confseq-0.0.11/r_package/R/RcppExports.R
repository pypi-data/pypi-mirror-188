# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Logarithm of mixture supermartingale for the one- or two-sided normal
#' mixture.
#' @param s value of the underlying martingale
#' @param v intrinsic time value
#' @param v_opt intrinsic time value for which the corresponding boundary is
#'   optimized
#' @param alpha_opt alpha for which the corresponding boundary is optimized
#' @param is_one_sided if FALSE, use the two-sided normal mixture
#' @examples
#' normal_log_mixture(10, 100, 100)
#' normal_log_mixture(c(10, 20), c(100, 400), 100, is_one_sided=FALSE)
#' @export
normal_log_mixture <- function(s, v, v_opt, alpha_opt = 0.05, is_one_sided = TRUE) {
    .Call(`_confseq_normal_log_mixture`, s, v, v_opt, alpha_opt, is_one_sided)
}

#' One- or two-sided normal mixture uniform boundary.
#' @param v intrinsic time value
#' @param alpha the error / crossing probability of the boundary
#' @param v_opt intrinsic time value for which the boundary is optimized
#' @param alpha_opt alpha for which the boundary is optimized
#' @param is_one_sided if FALSE, use the two-sided normal mixture
#' @examples
#' normal_mixture_bound(c(100, 200), .05, 100)
#' normal_mixture_bound(100, c(.05, .01), 100)
#' @export
normal_mixture_bound <- function(v, alpha, v_opt, alpha_opt = 0.05, is_one_sided = TRUE) {
    .Call(`_confseq_normal_mixture_bound`, v, alpha, v_opt, alpha_opt, is_one_sided)
}

#' Logarithm of mixture supermartingale for the gamma-exponential mixture.
#' @inherit normal_log_mixture
#' @param c sub-exponential scale parameter
#' @examples
#' gamma_exponential_log_mixture(c(10, 20), c(100, 400), 100, 2)
#' @export
gamma_exponential_log_mixture <- function(s, v, v_opt, c, alpha_opt = 0.05) {
    .Call(`_confseq_gamma_exponential_log_mixture`, s, v, v_opt, c, alpha_opt)
}

#' Gamma-exponential uniform boundary.
#' @inherit normal_mixture_bound
#' @param c sub-exponential scale parameter
#' @examples
#' gamma_exponential_mixture_bound(c(100, 200), .05, 100, 2)
#' @export
gamma_exponential_mixture_bound <- function(v, alpha, v_opt, c, alpha_opt = 0.05) {
    .Call(`_confseq_gamma_exponential_mixture_bound`, v, alpha, v_opt, c, alpha_opt)
}

#' Logarithm of mixture supermartingale for the gamma-Poisson mixture.
#' @inherit normal_log_mixture
#' @param c sub-Poisson scale parameter
#' @examples
#' gamma_poisson_log_mixture(c(10, 20), c(100, 400), 100, 2)
#' @export
gamma_poisson_log_mixture <- function(s, v, v_opt, c, alpha_opt = 0.05) {
    .Call(`_confseq_gamma_poisson_log_mixture`, s, v, v_opt, c, alpha_opt)
}

#' Gamma-Poisson uniform boundary.
#' @inherit normal_mixture_bound
#' @param c sub-Poisson scale parameter
#' @examples
#' gamma_poisson_mixture_bound(c(100, 200), .05, 100, 2)
#' @export
gamma_poisson_mixture_bound <- function(v, alpha, v_opt, c, alpha_opt = 0.05) {
    .Call(`_confseq_gamma_poisson_mixture_bound`, v, alpha, v_opt, c, alpha_opt)
}

#' Logarithm of mixture supermartingale for the beta-binomial mixture.
#' @inherit normal_log_mixture
#' @param g lower sub-Bernoulli range parameter
#' @param h upper sub-Bernoulli range parameter
#' @param is_one_sided if FALSE, use the two-sided beta-binomial mixture
#' @examples
#' beta_binomial_log_mixture(c(10, 20), c(100, 400), 100, .2, .8)
#' @export
beta_binomial_log_mixture <- function(s, v, v_opt, g, h, alpha_opt = 0.05, is_one_sided = TRUE) {
    .Call(`_confseq_beta_binomial_log_mixture`, s, v, v_opt, g, h, alpha_opt, is_one_sided)
}

#' Beta-binomial uniform boundary.
#' @inherit normal_mixture_bound
#' @inherit beta_binomial_log_mixture
#' @examples
#' beta_binomial_mixture_bound(c(100, 200), .05, 100, .2, .8)
#' @export
beta_binomial_mixture_bound <- function(v, alpha, v_opt, g, h, alpha_opt = 0.05, is_one_sided = TRUE) {
    .Call(`_confseq_beta_binomial_mixture_bound`, v, alpha, v_opt, g, h, alpha_opt, is_one_sided)
}

#' Polynomial stitched uniform boundary.
#' @inherit normal_mixture_bound
#' @param v_min intrinsic time for which boundary is optimized
#' @param c sub-gamma scale parameter
#' @param s controls how crossing probability is distribted over epochs
#' @param eta controls the spacing of epochs
#' @examples
#' poly_stitching_bound(c(100, 200), .05, 100)
#' @export
poly_stitching_bound <- function(v, alpha, v_min, c = 0, s = 1.4, eta = 2) {
    .Call(`_confseq_poly_stitching_bound`, v, alpha, v_min, c, s, eta)
}

#' Empirical process finite LIL bound.
#'
#' Based on Theorem 2 of the quantile paper. Bound has the form `A
#' sqrt((loglog(et / t_min) + C) / t)`, and is valid only for t >= t_min. C is
#' chosen to achieve the desired error probability `alpha`.
#'
#' This bound controls the deviations of the empirical CDF from the true CDF
#' uniformly over x and time, or yields a confidence sequences uniform over
#' quantiles and time (Corollary 2 of the quantile paper).
#'
#' @param t number of samples observed
#' @param alpha error / crossing probability of the boundary
#' @param t_min first time at which boundary is valid
#' @param A leading constant in the bound
#' @examples
#' empirical_process_lil_bound(1000, .05, 100)
#' @export
empirical_process_lil_bound <- function(t, alpha, t_min, A = 0.85) {
    .Call(`_confseq_empirical_process_lil_bound`, t, alpha, t_min, A)
}

#' "Double stitching" bound (Theorem 3 of the quantile paper).
#'
#' Yields a confidence sequence uniform over quantiles and time.
#'
#' @param quantile_p designates which quantile we wish to bound
#' @param t number of samples observed
#' @param alpha error / crossing probability of the boundary
#' @param t_opt sample size for which the bound is optimized
#' @param delta controls the fineness of the quantile grid used in construction
#'   of the bound
#' @param s controls how crossing probability is distribted over epochs
#' @param eta controls the spacing of epochs
#' @examples
#' double_stitching_bound(c(.1, .5, .9), 1000, .05, 100)
#' @export
double_stitching_bound <- function(quantile_p, t, alpha, t_opt, delta = 0.5, s = 1.4, eta = 2) {
    .Call(`_confseq_double_stitching_bound`, quantile_p, t, alpha, t_opt, delta, s, eta)
}

#' Confidence sequence for [0, 1]-bounded distributions.
#'
#' This function returns confidence bounds for the mean of a Bernoulli
#' distribution, or more generally, any distribution with support in the unit
#' interval [0, 1]. (This applies to any bounded distribution after rescaling.)
#' The confidence bounds form a confidence sequence, so are guaranteed to cover
#' the true mean uniformly over time with probability 1 - `alpha`.
#'
#' @param num_successes number of "successful" Bernoulli trials seen so far, or
#'   more generally, sum of observed outcomes
#' @param num_trials total number of observations seen so far
#' @param alpha 1 - confidence level
#' @param t_opt sample size for which confidence sequence is optimized
#' @param alpha_opt 1 - confidence level for which confidence is optimized
#' @return a list with named elements `lower` and `upper` giving lower and
#'   upper confidence bounds, respectively
#' @examples
#' bernoulli_confidence_interval(c(50, 500, 5000), c(100, 1000, 10000), .05,
#'                               1000)
#' @export
bernoulli_confidence_interval <- function(num_successes, num_trials, alpha, t_opt, alpha_opt = 0.05) {
    .Call(`_confseq_bernoulli_confidence_interval`, num_successes, num_trials, alpha, t_opt, alpha_opt)
}

#' Two-sample, sequential test of equal quantiles.
#'
#' This function tests the null that two i.i.d. samples are drawn from
#' populations with the same `quantile_p` quantile. It returns a two-tailed,
#' always-valid p-value.
#'
#' @param a_values values observed so far from the first sample
#' @param b_values values observed so far from the second samples
#' @param quantile_p designates which quantile we wish to test
#' @param t_opt sample size for which test is optimized
#' @param alpha_opt level for which test is optimized
#' @examples
#' quantile_ab_p_value(1:1000, 86:1085, .5, 100)
#' @export
quantile_ab_p_value <- function(a_values, b_values, quantile_p, t_opt, alpha_opt = 0.05) {
    .Call(`_confseq_quantile_ab_p_value`, a_values, b_values, quantile_p, t_opt, alpha_opt)
}

