{"base": {"type": "module", "under": {"attribute_dict": {"type": "module", "under": {"AttributeDict": {"type": "object", "under": {}, "doc": "", "path": "yutils.base.attribute_dict.AttributeDict"}}, "doc": "", "path": "yutils.base.attribute_dict"}, "generic_object": {"type": "module", "under": {"GenericObject": {"type": "object", "under": {}, "doc": "\n    A generic object you can easily use for your scripts, with a pprint and a str/repr for easy printing\n    ", "path": "yutils.base.generic_object.GenericObject", "init_doc": "\n        :param object_name: The name for your object!\n        :type object_name: str\n        "}, "dict_to_generic_object": {"type": "function", "under": {}, "doc": "\n    Converts a dictionary (recursively) to a GenericObject, with keys as attributes.\n\n    :param dictionary: dictionary to convert (key-values will be converted to attribute-values)\n    :type dictionary: dict\n    :param object_name: a name for your new object's type\n    :type object_name: str\n    :return: GenericObject object\n    ", "path": "yutils.base.generic_object.dict_to_generic_object"}}, "doc": "", "path": "yutils.base.generic_object"}, "input_checker": {"type": "module", "under": {"InputChecker": {"type": "object", "under": {}, "doc": "", "path": "yutils.base.input_checker.InputChecker", "init_doc": "\n        Base object for making a Python object more static-typed.\n        It is useful for checking __init__ argument inputs (type and content).\n\n        Type check is defined by _INPUT_TYPES class constant. (see yutils.tools.check_object_type for usage)\n        Option check is defined by _INPUT_OPTIONS class constant.\n\n        This also:\n            - creates self._inputs as the inputs dict given, as an AttributeDict.\n            - adds each input in inputs as an attribute to your object.\n\n        :param inputs: your __init__ inputs, can be anything you wish to check\n\n        :raises: yutils.exceptions.WrongDatatype if any input is not of the specified type, defined by _INPUT_TYPES\n                 yutils.exceptions.InputError if any input is not one of the options, defined by _INPUT_OPTIONS\n        "}}, "doc": "", "path": "yutils.base.input_checker"}, "list_container": {"type": "module", "under": {"ListContainer": {"type": "object", "under": {}, "doc": "\n    An object that wraps a list, allowing you to use your object as a list and configure it as you wish.\n    ", "path": "yutils.base.list_container.ListContainer", "init_doc": "\n        :param _list: the original list you wish to keep in the backbone of your object\n        :type _list: list\n        :param _objects_type: a plural name for your objects in your ListContainer! This is for printing your object.\n                              For Example:\n                              >>> class Students(ListContainer):\n                              >>>     def __init__(self):\n                              >>>         super(Students, self).__init__([], 'students')\n        :type _objects_type: str\n        "}}, "doc": "", "path": "yutils.base.list_container"}, "pretty_printer": {"type": "module", "under": {"PrintableObject": {"type": "object", "under": {}, "doc": "\n    An object you can derive from, that has a pprint method - printing all set attributes\n    ", "path": "yutils.base.pretty_printer.PrintableObject"}}, "doc": "", "path": "yutils.base.pretty_printer"}, "updating_dict": {"type": "module", "under": {"DictValueList": {"type": "object", "under": {}, "doc": "", "path": "yutils.base.updating_dict.DictValueList", "init_doc": "Initialize self.  See help(type(self)) for accurate signature."}, "UpdatingDict": {"type": "object", "under": {}, "doc": "", "path": "yutils.base.updating_dict.UpdatingDict", "init_doc": "Initialize self.  See help(type(self)) for accurate signature."}}, "doc": "", "path": "yutils.base.updating_dict"}}, "doc": "", "path": "yutils.base"}, "conn": {"type": "module", "under": {"sql_connection_details": {"type": "module", "under": {"ConnectionDetails": {"type": "object", "under": {}, "doc": "", "path": "yutils.conn.sql_connection_details.ConnectionDetails", "init_doc": "Initialize self.  See help(type(self)) for accurate signature."}, "ElasticConnectionDetails": {"type": "object", "under": {}, "doc": "", "path": "yutils.conn.sql_connection_details.ElasticConnectionDetails", "init_doc": "Initialize self.  See help(type(self)) for accurate signature."}, "MSSQLConnectionDetails": {"type": "object", "under": {}, "doc": "", "path": "yutils.conn.sql_connection_details.MSSQLConnectionDetails", "init_doc": "Initialize self.  See help(type(self)) for accurate signature."}, "MySQLConnectionDetails": {"type": "object", "under": {}, "doc": "", "path": "yutils.conn.sql_connection_details.MySQLConnectionDetails", "init_doc": "Initialize self.  See help(type(self)) for accurate signature."}, "OracleConnectionDetails": {"type": "object", "under": {}, "doc": "", "path": "yutils.conn.sql_connection_details.OracleConnectionDetails", "init_doc": "Initialize self.  See help(type(self)) for accurate signature."}}, "doc": "", "path": "yutils.conn.sql_connection_details"}}, "doc": "", "path": "yutils.conn"}, "exceptions": {"type": "module", "under": {"exceptions": {"type": "module", "under": {"CodeMistake": {"type": "object", "under": {}, "doc": "\n    Gets raised to find mistakes when writing code\n    ", "path": "yutils.exceptions.exceptions.CodeMistake", "init_doc": "\n        :param mistake_string: an error message explaining why this was raised\n        :type mistake_string: str\n        "}, "InputError": {"type": "object", "under": {}, "doc": "\n    Gets raised when the input wasn't as expected (e.g. isn't a valid option)\n    ", "path": "yutils.exceptions.exceptions.InputError", "init_doc": "\n        :param error_string: an error message explaining the InputError\n        :type error_string: str\n        "}, "MissingAttribute": {"type": "object", "under": {}, "doc": "\n    Gets raised when an attribute was expected in a certain class\n    ", "path": "yutils.exceptions.exceptions.MissingAttribute", "init_doc": "\n        :param class_object: the object itself that is missing an attribute\n        :type class_object: object\n        :param attribute_name: the name of the attribute that is missing\n        :type attribute_name: str\n        "}, "MissingInput": {"type": "object", "under": {}, "doc": "\n    Gets raised when an input was expected in a certain class but not received\n    ", "path": "yutils.exceptions.exceptions.MissingInput", "init_doc": "\n        :param class_object: the object itself that is missing an attribute\n        :type class_object: object\n        :param attribute_name: the name of the attribute that is missing\n        :type attribute_name: str\n        "}, "UncaughtEndCase": {"type": "object", "under": {}, "doc": "\n    Gets raised to catch unexpected cases in the future\n    ", "path": "yutils.exceptions.exceptions.UncaughtEndCase", "init_doc": "\n        :param explanation: an optional string to explain the end case.\n                            Default: 'An uncaught end case was found. Check it out!'\n        :type explanation: str\n        "}, "UserCancellation": {"type": "object", "under": {}, "doc": "\n    Gets raised when a user chooses to cancel an operation, and you wish the program to abort.\n    ", "path": "yutils.exceptions.exceptions.UserCancellation", "init_doc": "\n        :param operation_name: (optional) the operation the user chose to cancel\n        :type operation_name: (optional) str\n        "}, "WrongDatatype": {"type": "object", "under": {}, "doc": "\n    Gets raised when something isn't the right datatype as was expected\n    ", "path": "yutils.exceptions.exceptions.WrongDatatype", "init_doc": "\n        :param name: object name\n        :type name: str\n        :param expectation: expected type\n        :type expectation: type or str\n        :param reality: the object's actual type\n        :type reality: type or str\n        "}, "WrongInputDatatype": {"type": "object", "under": {}, "doc": "\n    Gets raised when an input argument isn't the right datatype as was expected\n    ", "path": "yutils.exceptions.exceptions.WrongInputDatatype", "init_doc": "\n        :param name: object name\n        :type name: str\n        :param expectation: expected type\n        :type expectation: type or str\n        :param reality: the object's actual type\n        :type reality: type or str\n        "}, "YutilsException": {"type": "object", "under": {}, "doc": "", "path": "yutils.exceptions.exceptions.YutilsException", "init_doc": "Initialize self.  See help(type(self)) for accurate signature."}}, "doc": "", "path": "yutils.exceptions.exceptions"}}, "doc": "", "path": "yutils.exceptions"}, "match_arabic_nls_lang": {"type": "function", "under": {}, "doc": "", "path": "yutils.match_arabic_nls_lang"}, "ml": {"type": "module", "under": {"classification": {"type": "module", "under": {"LogisticRegressionClassifier": {"type": "object", "under": {}, "doc": "", "path": "yutils.ml.classification.LogisticRegressionClassifier"}, "LogisticRegressionOptimizedClassifier": {"type": "object", "under": {}, "doc": "", "path": "yutils.ml.classification.LogisticRegressionOptimizedClassifier"}, "MultiClassClassification": {"type": "object", "under": {}, "doc": "", "path": "yutils.ml.classification.MultiClassClassification"}}, "doc": "", "path": "yutils.ml.classification"}, "features": {"type": "module", "under": {"FeatureNormalizer": {"type": "object", "under": {}, "doc": "", "path": "yutils.ml.features.FeatureNormalizer", "init_doc": "\n        Normalizes features for a ML object\n\n        :param info: info to normalize, across column axis (normalizes each column by different normalization data)\n        :type info:\n        "}}, "doc": "", "path": "yutils.ml.features"}, "linear_regression": {"type": "module", "under": {"LinearRegression": {"type": "object", "under": {}, "doc": "", "path": "yutils.ml.linear_regression.LinearRegression", "init_doc": "\n        Not written yet...\n\n        :param training_data:\n        :param training_results:\n        :param learning_rate:\n        :param iterations:\n        :param normalize_data:\n        :param verbose:\n        "}, "NormalEquation": {"type": "object", "under": {}, "doc": "", "path": "yutils.ml.linear_regression.NormalEquation", "init_doc": "\n        Not explained yet...\n\n        :param training_data:\n        :param training_results:\n        :param assess_for_warning:\n        :param verbose:\n        "}}, "doc": "", "path": "yutils.ml.linear_regression"}, "ml_base": {"type": "module", "under": {"MLObject": {"type": "object", "under": {}, "doc": "", "path": "yutils.ml.ml_base.MLObject", "init_doc": "\n        Base object for making a Python object more static-typed.\n        It is useful for checking __init__ argument inputs (type and content).\n\n        Type check is defined by _INPUT_TYPES class constant. (see yutils.tools.check_object_type for usage)\n        Option check is defined by _INPUT_OPTIONS class constant.\n\n        This also:\n            - creates self._inputs as the inputs dict given, as an AttributeDict.\n            - adds each input in inputs as an attribute to your object.\n\n        :param inputs: your __init__ inputs, can be anything you wish to check\n\n        :raises: yutils.exceptions.WrongDatatype if any input is not of the specified type, defined by _INPUT_TYPES\n                 yutils.exceptions.InputError if any input is not one of the options, defined by _INPUT_OPTIONS\n        "}, "create_data_from_text_file": {"type": "function", "under": {}, "doc": "", "path": "yutils.ml.ml_base.create_data_from_text_file"}}, "doc": "", "path": "yutils.ml.ml_base"}, "regression": {"type": "module", "under": {"Regression": {"type": "object", "under": {}, "doc": "", "path": "yutils.ml.regression.Regression"}}, "doc": "", "path": "yutils.ml.regression"}}, "doc": "", "path": "yutils.ml"}, "queries": {"type": "module", "under": {"db_connection": {"type": "module", "under": {"db_connection": {"type": "module", "under": {"DBConnection": {"type": "object", "under": {}, "doc": "\n    Wraps a connection to a DB, for executing SQL queries, using given connection_details.\n    ", "path": "yutils.queries.db_connection.db_connection.DBConnection", "init_doc": "\n        :param connection_details: Details for connection to the wanted DB\n        :type: connection_details: yutils.conn.sql_connection_details.ConnectionDetails\n        :param verbose: If to print warnings or not\n        :type verbose: bool\n        "}}, "doc": "", "path": "yutils.queries.db_connection.db_connection"}, "fetchers": {"type": "module", "under": {"base_fetcher": {"type": "module", "under": {}, "doc": "", "path": "yutils.queries.db_connection.fetchers.base_fetcher"}, "elastic": {"type": "module", "under": {"ElasticSearchFetcher": {"type": "object", "under": {}, "doc": "", "path": "yutils.queries.db_connection.fetchers.elastic.ElasticSearchFetcher"}}, "doc": "", "path": "yutils.queries.db_connection.fetchers.elastic"}, "mssql": {"type": "module", "under": {"MSSQLFetcher": {"type": "object", "under": {}, "doc": "", "path": "yutils.queries.db_connection.fetchers.mssql.MSSQLFetcher"}}, "doc": "", "path": "yutils.queries.db_connection.fetchers.mssql"}, "mysql": {"type": "module", "under": {"MySQLFetcher": {"type": "object", "under": {}, "doc": "", "path": "yutils.queries.db_connection.fetchers.mysql.MySQLFetcher"}}, "doc": "", "path": "yutils.queries.db_connection.fetchers.mysql"}, "oracle": {"type": "module", "under": {"OracleFetcher": {"type": "object", "under": {}, "doc": "", "path": "yutils.queries.db_connection.fetchers.oracle.OracleFetcher"}}, "doc": "", "path": "yutils.queries.db_connection.fetchers.oracle"}}, "doc": "", "path": "yutils.queries.db_connection.fetchers"}}, "doc": "", "path": "yutils.queries.db_connection"}, "oracle_field_list_format": {"type": "module", "under": {"format_oracle_field_list": {"type": "function", "under": {}, "doc": "\n    Takes a list that can be more than 999 values long, and wraps them in SQL OR clauses.\n    This is useful because Oracle can only accept lists 1000 values long.\n\n    :param field_name: the name of the column you are querying\n    :type field_name: str\n    :param value_list: list of your values to format into the query\n    :type value_list: list of str\n\n    :return: formatted string containing your new WHERE clause\n    :rtype: unicode\n    ", "path": "yutils.queries.oracle_field_list_format.format_oracle_field_list"}}, "doc": "", "path": "yutils.queries.oracle_field_list_format"}}, "doc": "", "path": "yutils.queries"}, "tools": {"type": "module", "under": {"case_conversions": {"type": "module", "under": {"camel_back_to_snake_case": {"type": "function", "under": {}, "doc": "\n    Turns a camelBack word to a snake_case word\n\n    :param camel_back_word: wordInCamelCase\n    :return: a_word_in_snake_case\n    ", "path": "yutils.tools.case_conversions.camel_back_to_snake_case"}, "camel_case_to_snake_case": {"type": "function", "under": {}, "doc": "\n    Turns a CamelCase word to a snake_case word\n\n    :param camel_case_word: AWordInCamelCase\n    :return: a_word_in_snake_case\n    ", "path": "yutils.tools.case_conversions.camel_case_to_snake_case"}, "snake_case_to_camel_back": {"type": "function", "under": {}, "doc": "\n    Turns a snake_case word to a camelBack word\n\n    :param snake_case_word: a_word_in_snake_case\n    :return: wordInCamelCase\n    ", "path": "yutils.tools.case_conversions.snake_case_to_camel_back"}, "snake_case_to_camel_case": {"type": "function", "under": {}, "doc": "\n    Turns a snake_case word to a CamelCase word\n\n    :param snake_case_word: a_word_in_snake_case\n    :return: AWordInCamelCase\n    ", "path": "yutils.tools.case_conversions.snake_case_to_camel_case"}}, "doc": "", "path": "yutils.tools.case_conversions"}, "check_object_type": {"type": "function", "under": {}, "doc": "\n    This checks the types of an object using a certain syntax:\n    Lets say we have an object_to_check and the types_to_validate.\n    The object_to_check is the object\n\n    :param object_to_check: the object you wish to check its type, and raise an exception should its type not be correct\n    :type object_to_check: ....that's what we're here for....\n    :param types_to_validate: defines the wanted types for the object to check:\n    :type types_to_validate:\n                type - checks that object_to_check is of that type\n                        Example: float will make sure object_to_check is a float\n                list of types - checks that object_to_check is one of the types in the list\n                        Example: [int, float] will make sure object_to_check is either an int or a float\n                tuple of types - checks hierarchically:\n                                    checks that object_to_check is of the type of the first item,\n                                    then checks that each item in object_to_check is of the type of the second item,\n                                    etc.\n                                 Remember, all types in the tuple except the last must support indexing.\n                        Example: (list, str) will make sure object_to_check is a list of strings\n                                 (tuple, [int, float]) will make sure object_to_check is a tuple of either ints or floats\n                dict - checks that object_to_check is an object. It's type is defined by key 'type',\n                       with other keys to be checked as the object's attributes.\n                        Example: {'type': Person, 'age': int} will make sure object_to_check is a Person object,\n                                 with an 'age' attribute that is an int.\n                All values can have as many recursive dimensions as wanted.\n    :param input_name: Do not use, this is for recursive inner use.\n\n    More examples\n    Lets say we create:\n\n    integer = 13\n    unicode_str = u'foo'\n    int_list = list(range(10))\n    input_object = MyObject()\n    input_object.num = 3\n    input_object.lis = [1, 'bar']\n    input_object.3dlist = [[(1, 2, 3), (1, 1, 1)], [('a', 'b', 'c'), [7, 8, 9]]]\n\n    We can send:\n    check_object_type(integer, int)\n    check_object_type(unicode_str, unicode)\n    check_object_type(int_list, (list, int))\n    check_object_type(input_object, {'type': MyObject,\n                                     'num': int,\n                                     'lis': (list, [int, str]),\n                                     '3dlist': (list, list, [tuple, list], [int, str, unicode])\n                                     })\n\n    :raises:\n             Because of invalid inputs:\n                yutils.exceptions.CodeMistake - When no 'type' key is found (for when types_to_validate is a dict)\n                yutils.exceptions.WrongDatatype - When no type type is found when isinstance-ing an object's type\n             Exceptions raised by check:\n                yutils.exceptions.WrongInputDatatype - When the type is not correct during validation\n                yutils.exceptions.MissingInput - When an attribute is missing (for when types_to_validate is a dict)\n    ", "path": "yutils.tools.check_object_type"}, "equivilence": {"type": "function", "under": {}, "doc": "\n    Divides an iterator to groups, based on the function's result of every item in the iterator.\n    Returns dict of lists.\n\n    Example:\n        >>> equivilence(range(10), lambda x: x % 3)\n        >>>out>>> {0: [0, 3, 6, 9],\n        >>>out>>>  1: [1, 4, 7],\n        >>>out>>>  2: [2, 5, 8]}\n\n    :param iterator: an iterator you wish to run on and divide into groups\n    :type iterator: iterator\n    :param func: a function to activate on each iterator item - its result decides the return dict's keys.\n    :type func: function\n\n    :rtype: dict of lists (lists are groups of original iterator)\n    ", "path": "yutils.tools.equivilence"}, "files": {"type": "module", "under": {"get_file_length": {"type": "function", "under": {}, "doc": "\n    This function gets a file path and returns its length without reading it\n\n    :param file_path: path to return length of\n    :type file_path: str\n    :return: file length (in bytes)\n    :rtype: int\n    ", "path": "yutils.tools.files.get_file_length"}, "recursive_glob": {"type": "function", "under": {}, "doc": "\n    Returns a list of all files in directory including sub-directories.\n\n    :param dir_name: Dir name to glob recursively on\n    :type dir_name: str\n    :param ignore_hidden: if to ignore hidden files (that start with '.')\n    :type ignore_hidden: bool\n\n    :return: list of all files in the dir_name\n    :rtype: list of str\n    ", "path": "yutils.tools.files.recursive_glob"}, "save_file": {"type": "function", "under": {}, "doc": "\n    This function saves the file content to the destination dir (defaulted to \".\") as base_name + extension,\n    but adds a counter if needed.\n\n    :param content: the content of the file\n    :type content: str\n    :param file_base_name: the future file name without extension\n    :type file_base_name: str\n    :param extension: the file name extension (for example: 'xlsx')\n    :type extension: str\n    :param dest_dir: where to save the file\n                     Default: current directory\n    :type dest_dir: str\n\n    :return: full file path file was saved to\n    :rtype: unicode\n    ", "path": "yutils.tools.files.save_file"}}, "doc": "", "path": "yutils.tools.files"}, "list": {"type": "module", "under": {"make_list": {"type": "function", "under": {}, "doc": "", "path": "yutils.tools.list.make_list"}, "repr_list": {"type": "function", "under": {}, "doc": "\n    Returns an iterator as a string, representing the list.\n    :param iterator: the iterator you wish to represent as a list\n    :type iterator: iterator\n    :return: representation of your iterator as a list\n    :rtype: unicode\n    ", "path": "yutils.tools.list.repr_list"}}, "doc": "", "path": "yutils.tools.list"}, "numpy_tools": {"type": "module", "under": {"get_indices_containing_all_substrings": {"type": "function", "under": {}, "doc": "", "path": "yutils.tools.numpy_tools.get_indices_containing_all_substrings"}, "is_iterable": {"type": "function", "under": {}, "doc": "", "path": "yutils.tools.numpy_tools.is_iterable"}, "magic": {"type": "function", "under": {}, "doc": "\n    Implementation taken from https://stackoverflow.com/questions/47834140/numpy-equivalent-of-matlabs-magic\n    from user: user6655984\n    ", "path": "yutils.tools.numpy_tools.magic"}, "normalize_array": {"type": "function", "under": {}, "doc": "", "path": "yutils.tools.numpy_tools.normalize_array"}, "r2c": {"type": "function", "under": {}, "doc": "", "path": "yutils.tools.numpy_tools.r2c"}, "to_array": {"type": "function", "under": {}, "doc": "", "path": "yutils.tools.numpy_tools.to_array"}}, "doc": "", "path": "yutils.tools.numpy_tools"}, "pretty_print": {"type": "module", "under": {"pprint_dict": {"type": "function", "under": {}, "doc": "\n    Prints a dict in a very pretty way!\n\n    :param dictionary: your dict to print\n    :type dictionary: dict\n    :param long_value_limit: when a dict value exceeds this limit, it won't be printed\n                             Default: 120\n    :type long_value_limit: int\n    :param long_value_filler: A filler to print instead of a long value, must have {type} and {length} fields!\n                              Default: '<Long {type} object with repr length {length}>'\n    :type long_value_filler: str\n    :return: None\n    ", "path": "yutils.tools.pretty_print.pprint_dict"}, "pprint_list": {"type": "function", "under": {}, "doc": "\n    Prints a list in an easy, short way.\n\n    :param list_to_print: the list you wish to print\n    :type list_to_print: list\n    :return: None\n    ", "path": "yutils.tools.pretty_print.pprint_list"}}, "doc": "", "path": "yutils.tools.pretty_print"}, "str": {"type": "module", "under": {"turn_numeric": {"type": "function", "under": {}, "doc": "\n    Turns a string into either an int or a float\n\n    :param string: a string to assess\n    :type string: str\n\n    :rtype: str or float\n\n    :raises: TypeError if no type was found\n    ", "path": "yutils.tools.str.turn_numeric"}}, "doc": "", "path": "yutils.tools.str"}, "xlsx_creator": {"type": "module", "under": {"XLSXCreator": {"type": "object", "under": {}, "doc": "", "path": "yutils.tools.xlsx_creator.XLSXCreator", "init_doc": "\n        A class to create an XLSX file from a table.\n        It will format the table inside an actual excel's table, according to each field's width.\n\n        :param headers: The fields of the table (headers)\n        :type headers: list of unicode\n        :param table: The table\n        :type table: matrix - list of lists of the same lengths (cells may be any datatype)\n        :param output_path: The path where to save the excel\n        :type output_path: unicode\n        "}, "create_xlsx": {"type": "function", "under": {}, "doc": "\n    Creates an XLSX file from a table.\n    It will format the table inside an actual excel's table, according to each field's width.\n\n    :param headers: The fields of the table (headers)\n    :type headers: list of unicode\n    :param table: The table\n    :type table: matrix - list of lists of the same lengths (cells may be any datatype)\n    :param output_path: The path where to save the excel\n    :type output_path: unicode\n    ", "path": "yutils.tools.xlsx_creator.create_xlsx"}, "get_next_column": {"type": "function", "under": {}, "doc": "", "path": "yutils.tools.xlsx_creator.get_next_column"}, "get_next_letter": {"type": "function", "under": {}, "doc": "", "path": "yutils.tools.xlsx_creator.get_next_letter"}, "table_to_str": {"type": "function", "under": {}, "doc": "\n    matrix good for the function xlsxwriter.Worksheet.add_table(['data': table))\n    :param table: matrix - list of lists of the same lengths (cells may be any datatype)\n    :return: fully string matrix\n    ", "path": "yutils.tools.xlsx_creator.table_to_str"}}, "doc": "", "path": "yutils.tools.xlsx_creator"}}, "doc": "", "path": "yutils.tools"}}