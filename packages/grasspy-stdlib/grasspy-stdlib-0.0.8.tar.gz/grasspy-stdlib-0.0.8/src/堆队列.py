"""堆队列算法, 也称为优先队列算法 - heapq.py

堆是一个二叉树, 元素从 0 开始计数, 使用数组实现: 
对于所有 k, 都有 堆[k] <= 堆[2*k+1] 和 堆[k] <= 堆[2*k+2].

为了便于比较, 不存在的元素被认为是无限大. 
堆最有趣的特性在于最小的元素总是在根结点, 即堆[0].

用法:

堆 = []                # 创建一个空堆\n
堆压入(堆, 元素)        # 向堆中压入一个新元素\n
元素 = 堆弹出(堆)       # 从堆中弹出最小元素\n
元素 = 堆[0]            # 取堆中的最小元素但不弹出\n
堆起来(x)               # 将列表原位转换为堆\n
元素 = 堆替换(堆, 元素)  # 弹出并返回最小元素, 然后添加新元素; 堆大小不变

本模块的 API 与教科书堆算法实现有所不同, 具体区别有两方面:
- 使用从 0 开始的索引. 这使得节点和其孩子节点索引之间的关系不太直观但更合适, 
  因为 Python 使用从 0 开始的索引.
  
- 堆弹出() 方法返回最小元素而非最大元素 (这被称为 '小根堆', 教材中一般讲述 '大根堆').

基于这两方面, 把堆看作原生的 Python 列表也没什么奇怪的: 堆[0] 表示最小的元素, 
同时 堆.排序() 维护了堆的不变性!
"""

从 _heapq 导入 堆压入, 堆弹出, 堆起来, 堆压入弹出, 堆替换

从 heapq 导入 *

套路 合并(*可迭代对象, 键=空, 逆=假):
    """将多个已排序的输入合并为一个已排序的输出, 返回已排序值的迭代器.

    类似于 排序(迭代工具.链接(*可迭代对象)) 但返回一个生成器, 
    不会一次性地将数据全部放入内存, 并假定每个输入流都是已排序的 (从小到大).
    """
    生成 自 merge(*可迭代对象, key=键, reverse=逆)

套路 最小n项(n, 可迭代对象, 键=空):
    """从 可迭代对象 所定义的数据集中返回前 n 个最小元素组成的列表.

    等价于: 排序(可迭代对象, 键=键)[:n]
    """
    返回 nsmallest(n, 可迭代对象, key=键)

套路 最大n项(n, 可迭代对象, 键=空):
    """从 可迭代对象 所定义的数据集中返回前 n 个最大元素组成的列表.

    等价于: 排序(可迭代对象, 键=键, 逆=真)[:n]
    """
    返回 nlargest(n, 可迭代对象, key=键)
