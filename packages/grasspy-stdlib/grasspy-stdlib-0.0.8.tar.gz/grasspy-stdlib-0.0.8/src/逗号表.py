"""
读写/探查 CSV (逗号分隔值) 文件 - csv.py
"""
从 _csv 导入 注销方言, 获取方言, 列出所有方言, 字段大小限值
从 csv 导入 *
从 汉化通用 导入 _关键词参数中转英

__all__ = ["匚最少引号", "匚全部加引号", "匚非数字加引号", "匚不加引号",
           "爻错误", "〇方言", "__doc__", "excel", "excel_tab",
           "字段大小限值", "〇读取器", "〇写入器",
           "注册方言", "获取方言", "列出所有方言", "〇嗅探器",
           "注销方言", "__版本__", "〇字典读取器", "〇字典写入器",
           "unix_dialect"]

匚最少引号 = QUOTE_MINIMAL
匚全部加引号 = QUOTE_ALL
匚非数字加引号 = QUOTE_NONNUMERIC
匚不加引号 = QUOTE_NONE

爻错误 = Error

__版本__ = __version__

类 〇方言(Dialect):
    """描述 CSV 方言.

    必须创建其子类才能使用(参见 csv.excel). 有效属性如下:
    定界符, 引号字符, 转义符, 双引号, 跳过初始空白, 行结束符, 加引号.
    """
    定界符 = None
    引号字符 = None
    转义符 = None
    双引号 = None
    跳过初始空白 = None
    行结束符 = None
    加引号 = None

_方言属性字典 = {
    '定界符' : 'delimiter',
    '引号字符' : 'quotechar',
    '转义符' : 'escapechar',
    '双引号' : 'doublequote',
    '跳过初始空白' : 'skipinitialspace',
    '行结束符' : 'lineterminator',
    '加引号' : 'quoting'
}    

套路 注册方言(名称, 方言=空, **格式参数):
    """将一个字符串名称与一个方言类关联起来.
    
    可以给出 〇方言 的子类, 或给出格式关键词参数, 
    或两者都给出 (此时格式参数会覆盖对应的方言属性).
    """
    如果 方言:
        如果 方言.定界符 不是 空:
            方言.delimiter = 方言.定界符
        如果 方言.引号字符 不是 空:
            方言.quotechar = 方言.引号字符 
        如果 方言.转义符 不是 空:
            方言.escapechar = 方言.转义符
        如果 方言.双引号 不是 空:
            方言.doublequote = 方言.双引号
        如果 方言.跳过初始空白 不是 空:
            方言.skipinitialspace = 方言.跳过初始空白
        如果 方言.行结束符 不是 空:
            方言.lineterminator = 方言.行结束符
        如果 方言.加引号 不是 空:
            方言.quoting = 方言.加引号

    格式参数 = _关键词参数中转英(格式参数, _方言属性字典)
    register_dialect(名称, 方言, **格式参数)

套路 〇读取器(文件对象, 方言='excel', **格式参数) -> reader:
    """
    文件对象 参数可以是任何能在每次迭代时返回一行输入的对象,
    例如一个文件对象或列表.

    可选 方言 参数用于指定所用的方言.

    该函数还接受可选格式关键词参数, 后者会覆盖方言所提供的设置.

    返回一个迭代器. 每次迭代返回 CSV 文件的一行.
    """
    格式参数 = _关键词参数中转英(格式参数, _方言属性字典)
    返回 reader(文件对象, 方言, **格式参数)

套路 〇写入器(文件对象, 方言='excel', **格式参数) -> writer:
    """
    写入器 = 逗号表.〇写入器(文件对象 [, 方言='excel']
                            [, 格式关键词参数])\n
    取 行 于 序列:\n
        写入器.写一行(行)\n

    或\n

    写入器.写多行(多行)\n
    """
    格式参数 = _关键词参数中转英(格式参数, _方言属性字典)
    返回 writer(文件对象, 方言, **格式参数)

类 〇字典读取器(DictReader):
    """
    类似于常规 〇读取器, 但将每行中的信息映射到一个字典, 字典的键由 字段名称々 可选参数给出.
    如果省略 字段名称々, 则文件第一行中的值将用作字段名.
    """
    套路 __init__(分身, 文件对象, 字段名称々=None, 剩余数据键=None, 缺失数据值=None,
                方言="excel", *参数, **关键词参数):
        关键词参数 = _关键词参数中转英(关键词参数, _方言属性字典)
        super().__init__(文件对象, fieldnames=字段名称々, restkey=剩余数据键,
                restval=缺失数据值, dialect=方言, *参数, **关键词参数)
        分身.剩余数据键 = 剩余数据键
        分身.缺失数据值 = 缺失数据值
        分身.方言 = 方言
        # 分身.行号 = 分身.line_num

    @property
    套路 行号(分身):
        返回 分身.line_num
    
    @property
    套路 字段名称々(分身):
        返回 分身.fieldnames

    @字段名称々.setter
    套路 字段名称々(分身, 值):
        分身.fieldnames = 值


类 〇字典写入器(DictWriter):
    """
    操作上类似常规 〇写入器, 但会将字典映射到输出行.
    """
    套路 __init__(分身, 文件对象, 字段名称々, 缺失数据值="", 额外操作='报错',
                方言="excel", *参数, **关键词参数):
        如果 额外操作 == '报错': 额外操作 = 'raise'
        如果 额外操作 == '忽略': 额外操作 = 'ignore'
        关键词参数 = _关键词参数中转英(关键词参数, _方言属性字典)
        super().__init__(文件对象, 字段名称々, restval=缺失数据值, extrasaction=额外操作,
                dialect=方言, *参数, **关键词参数)
        分身.字段名称々 = 字段名称々
        分身.缺失数据值 = 缺失数据值
        分身.额外操作 = 额外操作

    套路 写表头(分身):
        返回 分身.writeheader()

    套路 写一行(分身, 行字典):
        返回 分身.writerow(行字典)
    
    套路 写多行(分身, 多行字典):
        返回 分身.writerows(多行字典)


类 〇嗅探器(Sniffer):
    """
    嗅探 CSV 文件的格式 (定界符/引号字符等). 返回方言对象.
    """
    套路 __init__(分身):
        分身.首选 = 分身.preferred = [',', '\t', ';', ' ', ':']

    套路 嗅探(分身, 样本, 可能定界符=空) -> 〇方言:
        """
        返回样本对应的方言(或 空).
        """
        返回 分身.sniff(样本, 可能定界符)

    套路 有表头(分身, 样本):
        返回 分身.has_header(样本)
