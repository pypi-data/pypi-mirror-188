"""
二分算法 (bisect)
"""
从 bisect 导入 *

套路 插入有序(a, x, 低=0, 高=空):
    """
    假设列表 a 为有序状态, 在 a 中插入 x 并保持有序.

    如果 x 已在 a 中, 则将其插在已有最右边 x 的右边.

    可选参数 '低' (默认为 0) 和 '高' (默认为 长(a)) 用于限定要搜索的切片.
    """
    如果 高 是 空:
        高 = 长(a)
    insort_right(a, x, 低, 高)

套路 二分(a, x, 低=0, 高=空):
    """
    假设列表 a 为有序状态, 返回在 a 中插入 x 的位置索引.

    返回值 i 使得 a[:i] 中的所有元素都 <= x, a[i:] 中的所有元素都 > x.
    如果 x 已在 a 中, 则将 x 插在已有最右边 x 之后.

    可选参数 '低' (默认为 0) 和 '高' (默认为 长(a)) 用于限定要搜索的切片.
    """
    如果 低 < 0:
        报 爻值错误('低 须为非负')
    如果 高 是 空:
        高 = 长(a)
    返回 bisect_right(a, x, 低, 高)

套路 插入有序_左(a, x, 低=0, 高=空):
    """
    假设列表 a 为有序状态, 在 a 中插入 x 并保持有序.

    如果 x 已在 a 中, 则将其插在已有最左边 x 的左边.

    可选参数 '低' (默认为 0) 和 '高' (默认为 长(a)) 用于限定要搜索的切片.
    """
    如果 高 是 空:
        高 = 长(a)
    insort_left(a, x, 低, 高)

套路 二分_左(a, x, 低=0, 高=空):
    """
    假设列表 a 为有序状态, 返回在 a 中插入 x 的位置索引.

    返回值 i 使得 a[:i] 中的所有元素都 < x, a[i:] 中的所有元素都 >= x.
    如果 x 已在 a 中, 则将 x 插在已有最左边 x 之前.

    可选参数 '低' (默认为 0) 和 '高' (默认为 长(a)) 用于限定要搜索的切片.
    """
    如果 低 < 0:
        报 爻值错误('低 须为非负')
    如果 高 是 空:
        高 = 长(a)
    返回 bisect_left(a, x, 低, 高)
