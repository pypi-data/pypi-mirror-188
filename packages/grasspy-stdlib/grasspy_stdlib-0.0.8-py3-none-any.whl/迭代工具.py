"""itertools 模块
提供用于创建和使用迭代器的函数工具.\n
\n
- 无限迭代器:\n
计数(起始=0, 步长=1) --> 起始, 起始+步长, 起始+2*步长, ...\n
循环(p) --> p0, p1, ... pn, p0, p1, ...\n
重复(元素 [,n]) --> 元素, 元素, 元素, ... 无穷或 n 次\n
\n
- 终止于最短输入序列的迭代器:\n
累算(p[, 函数]) --> p0, p0+p1, p0+p1+p2\n
链接(p, q, ...) --> p0, p1, ... pn, q0, q1, ...\n
链接.从可迭代对象([p, q, ...]) --> p0, p1, ... pn, q0, q1, ...\n
按选择器筛选(数据d, 选择器s) --> (d[0] 如果 s[0]), (d[1] 如果 s[1]), ...\n
从假循环(判断, 序列) --> 序列[m], 序列[m+1], 从判断结果为假开始\n
分组(可迭代对象[, 键函数]) --> 按键函数(v) 的值分组的子迭代器\n
筛选假(判断, 序列) --> 保留序列中 判断(元素) 为 假 的元素\n
迭代切片(序列, [起,] 止 [, 步长]) --> 序列[起:止:步长] 中的元素\n
结对(s) --> (s[0],s[1]), (s[1],s[2]), (s[2], s[3]), ...\n\
星号映射(函数, 序列) --> 函数(*序列[0]), 函数(*序列[1]), ...\n
分裂(it, n=2) --> (it1, it2 , ... itn) 一个迭代器分裂成 n 个, 类似细胞分裂\n
循环到假(判断, 序列) --> 序列[0], 序列[1], 直至判断结果为假\n
组队_最长(p, q, ...) --> (p[0], q[0]), (p[1], q[1]), ...\n
\n
- 排列组合生成器:\n
直积(p, q, ... [重复=1]) --> 即笛卡尔积\n
排列(p[, r])\n
组合(p, r)\n
组合_可重复(p, r)
"""

从 itertools 导入 *
导入 系统

套路 结对(可迭代对象):
    """输入迭代器中的元素两两成对, 返回一个迭代器.\n
    s -> (s0,s1), (s1,s2), (s2, s3), ...
    """
    返回 pairwise(可迭代对象)

套路 分组(可迭代对象, 键=空):
    "按照分组函数的值对元素进行分组, 返回组值和组内元素"
    返回 groupby(可迭代对象, 键)

套路 分裂(可迭代对象, n=2):
    "一个迭代器分裂成 n 个, 类似细胞分裂. 返回 n 个独立迭代器组成的元组"
    返回 tee(可迭代对象, n)

套路 循环(可迭代对象):
    """循环(p) --> p0, p1, ... pn, p0, p1, ...\n
    循环('ABCD') --> A B C D A B C D A B C D ...
    """
    返回 cycle(可迭代对象)

套路 从假循环(判断, 可迭代对象):
    "从 判断(元素) 的结果为 假 开始返回可迭代对象中的元素"
    返回 dropwhile(判断, 可迭代对象)

套路 循环到假(判断, 可迭代对象):
    "从可迭代对象中返回元素, 直至 判断(元素) 的结果为假"
    返回 takewhile(判断, 可迭代对象)

套路 星号映射(函数, 可迭代对象):
    """星号的作用是解包. 与预置函数 映射() 的区别可从下例看出:\n
    映射(乘方, [a1, a2, a3], [b1, b2, b3]) -> a1**b1, a2**b2, ...\n
    星号映射(乘方, [(a1, b1), (a2, b2), (a3, b3)]) -> a1**b1, a2**b2, ...\n
    可以看出, 星号映射() 使用起来更自然
    """
    返回 starmap(函数, 可迭代对象)

套路 链接(*可迭代对象):
    "链接多个列表或者其他可迭代对象"
    返回 chain(*可迭代对象)

链接.从可迭代对象 = chain.from_iterable # 链接() 的另一个构造函数

套路 组合(可迭代对象, r):
    """返回可迭代对象中元素的长度为 r 的组合\n
    组合(范围(4), 3) --> (0,1,2), (0,1,3), (0,2,3), (1,2,3)
    """
    返回 combinations(可迭代对象, r)

套路 组合_可重复(可迭代对象, r):
    """返回可迭代对象中元素的长度为 r 的组合, 元素允许重复\n
    组合_可重复(\'ABC\', 2) --> AA AB AC BB BC CC
    """
    返回 combinations_with_replacement(可迭代对象, r)

套路 排列(可迭代对象, r=空):
    """返回可迭代对象中元素的长度为 r 的排列\n
    排列(范围(3), 2) --> (0,1), (0,2), (1,0), (1,2), (2,0), (2,1)
    """
    返回 permutations(可迭代对象, r)

套路 累算(可迭代对象, 函数=空, *, 初始值=空):
    """返回累计计算结果的序列\n
    累算([1, 2, 3, 4, 5]) --> 1 3 6 10 15\n
    累算([1, 2, 3, 4, 5], 雷锋 x, y: x*y) --> 1, 2, 6, 24, 120\n
    累算([1, 2, 3, 4, 5], 运算符.真除法, 初始值=120) --> 120, 120.0, 60.0, 20.0, 5.0, 1.0\n
    """
    返回 accumulate(可迭代对象, 函数, initial=初始值)

套路 按选择器筛选(数据, 选择器):
    """如果选择器的某元素为真, 则返回数据中对应的元素. 选择器可以是一个真值表\n
    按选择器筛选('ABCDEF', [1,0,1,0,1,1]) --> A C E F
    """
    返回 compress(数据, 选择器)

套路 筛选假(函数, 可迭代对象):
    """返回可迭代对象中 函数(元素) 为 假 的元素.\n
    如果函数为 空, 则返回可迭代对象中的 假 元素
    """
    返回 filterfalse(函数, 可迭代对象)

套路 计数(起始=0, 步长=1):
    """计数(起始, 步长) --> 起始, 起始+步长, 起始+2*步长\n
    计数(10) --> 10 11 12 13 14 ...\n
    计数(2.5, 0.5) -> 2.5 3.0 3.5 ...
    """
    返回 count(start=起始, step=步长)

套路 重复(对象, 次数=系统.最大大小):
    """重复(元素 [,n]) --> 元素, 元素, 元素, ... 无穷或 n 次\n
    列表(映射(乘方, 范围(5), 重复(2))) --> [0, 1, 4, 9, 16]
    """
    返回 repeat(对象, 次数)

套路 直积(*可迭代对象, 重复=1):
    """返回可迭代对象的笛卡尔积.\n
    直积(A, 重复=4) == 直积(A, A, A, A).\n
    直积('ab', 范围(3)) --> ('a',0) ('a',1) ('a',2) ('b',0) ('b',1) ('b',2)\n
    直积((0,1), (0,1), (0,1)) --> (0,0,0) (0,0,1) (0,1,0) (0,1,1) (1,0,0) ...
    """
    返回 product(*可迭代对象, repeat=重复)

套路 迭代切片(可迭代对象, *参数):
    """对可迭代对象进行切片\n
    迭代切片(可迭代对象, 止) \n
    迭代切片(可迭代对象, 起, 止)\n
    迭代切片(可迭代对象, 起, 止, 步长)
    """
    返回 islice(可迭代对象, *参数)

套路 组队_最长(迭代1, *其他可迭代对象):
    """同预置 组队() 函数的区别在于:\n
    组队() 结束取决于里面最短的可迭代对象\n
    组队_最长() 结束取决于里面最长的可迭代对象
    """
    返回 zip_longest(迭代1, *其他可迭代对象)
