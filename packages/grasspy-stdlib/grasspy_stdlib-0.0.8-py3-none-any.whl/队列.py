"""多生产者、多消费者队列."""

从 queue 导入 *

已空异常 = Empty
已空异常.__doc__ = "队列.获取(阻塞=0)/获取_不等待() 抛出的异常"

已满异常 = Full
已满异常.__doc__ = "队列.入列(阻塞=0)/入列_不等待() 抛出的异常"

类 〇队列(Queue):
    """以给定的最大大小创建一个队列对象.

    如果 最大大小 <= 0, 则队列大小为无穷大.
    """
    套路 __init__(分身, 最大大小=0):
        super().__init__(maxsize=最大大小)

    套路 任务已完成(分身):
        """表示之前入列的一个任务已经完成.
        
        由队列的消费者线程使用. 每一次 获取() 得到一个任务, 接下来的
        任务已完成() 调用告诉队列该任务已经处理完毕.

        如果当前一个 并入() 正在阻塞, 它将在队列中的所有任务都处理完时恢复执行,
        即对每一个由 入列() 放入队列的任务, 都收到一个对应的 任务已完成() 调用.

        如果调用次数超过队列中放入的元素数量, 则报值错误.
        """
        返回 分身.task_done()

    套路 并入(分身):
        """阻塞至队列中的所有元素都被获取和处理完毕.

        只要有元素被放入队列, 未完成的任务数就会增加.
        当消费者线程调用 任务已完成() 时,
        即消费者取得某项任务并完成其所有工作, 未完成任务数就会减少.
        当未完成任务数降到 0 时, 并入() 解除阻塞.
        """
        返回 分身.join()
    
    套路 队列大小(分身):
        """返回队列的估计大小 (不可靠!)
        """
        返回 分身.qsize()
    
    套路 已空(分身):
        """若队列已空则返回真, 否则返回假 (不可靠!)
        """
        返回 分身.empty()
    
    套路 已满(分身):
        """若队列已满则返回真, 否则返回假 (不可靠!)
        """
        返回 分身.full()

    套路 入列(分身, 元素, 阻塞=真, 超时=空):
        """将一个元素放入队列中.

        可选参数皆为默认值时, 则在必要时阻塞, 直至有空位.

        若 '阻塞' 为 真 且 '超时' 为非负数, 则阻塞至多 '超时' 秒, 
        届时若无空位则抛出已满异常.

        若 '阻塞' 为 假, 则在当下有空位时将元素放入队列, 否则抛出
        已满异常 (这种情况下忽略 '超时' 参数).
        """
        返回 分身.put(元素, block=阻塞, timeout=超时)
    
    套路 获取(分身, 阻塞=真, 超时=空):
        """从队列中移除一个元素并返回该元素.

        可选参数皆为默认值时, 则在必要时阻塞, 直至有元素可用.

        若 '阻塞' 为 真 且 '超时' 为非负数, 则阻塞至多 '超时' 秒, 
        届时若无元素可用则抛出已空异常.

        若 '阻塞' 为 假, 则在当下有元素可用时返回元素, 否则抛出
        已空异常 (这种情况下忽略 '超时' 参数).
        """
        返回 分身.get(block=阻塞, timeout=超时)
    
    套路 入列_不等待(分身, 元素):
        """将一个元素放入队列中而不阻塞.

        只有当下有空位时, 才将元素放入队列, 否则抛出已满异常.
        """
        返回 分身.put(元素, block=假)
    
    套路 获取_不等待(分身):
        """从队列中移除一个元素并返回该元素而不阻塞.

        只有当下有元素可用时才获取元素, 否则抛出已空异常.
        """
        返回 分身.get(block=假)

类 〇优先级队列(〇队列, PriorityQueue):
    """队列类的变体, 按优先级检索待处理条目 (最小最先).

    条目通常为元组形式: (优先级, 数据)
    """    

类 〇后进先出队列(〇队列, LifoQueue):
    """队列类的变体, 最近入列的条目最先检索.
    """    

类 〇简单队列(SimpleQueue):
    """简单无界的先进先出 (FIFO) 队列.
    """
    套路 入列(分身, 元素, 阻塞=真, 超时=空):
        """将元素放入队列中.

        可选参数被忽略, 仅为兼容性而提供. 此方法永远不会阻塞.
        """
        返回 分身.put(元素, block=阻塞, timeout=超时)
    
    套路 获取(分身, 阻塞=真, 超时=空):
        """从队列中移除一个元素并返回该元素.

        可选参数皆为默认值时, 则在必要时阻塞, 直至有元素可用.

        若 '阻塞' 为 真 且 '超时' 为非负数, 则阻塞至多 '超时' 秒, 
        届时若无元素可用则抛出已空异常.

        若 '阻塞' 为 假, 则在当下有元素可用时返回元素, 否则抛出
        已空异常 (这种情况下忽略 '超时' 参数).
        """
        返回 分身.get(block=阻塞, timeout=超时)
    
    套路 入列_不等待(分身, 元素):
        """将一个元素放入队列中而不阻塞.

        完全等价于 入列(元素), 仅为兼容性而提供.
        """
        返回 分身.put(元素, block=假)
    
    套路 获取_不等待(分身):
        """从队列中移除一个元素并返回该元素而不阻塞.

        只有当下有元素可用时才获取元素, 否则抛出已空异常.
        """
        返回 分身.get(block=假)

    套路 已空(分身):
        """若队列已空则返回真, 否则返回假 (不可靠!)
        """
        返回 分身.empty()

    套路 队列大小(分身):
        """返回队列的估计大小 (不可靠!)
        """
        返回 分身.qsize()
  