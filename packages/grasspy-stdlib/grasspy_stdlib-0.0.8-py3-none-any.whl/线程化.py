"""线程模块, 模仿 Java 线程模型的一个子集 - threading.py"""

从 threading 导入 *
从 typing 导入 List

获取标识 = get_ident
获取原生id = get_native_id
爻线程错误 = ThreadError

匚超时最大值 = TIMEOUT_MAX

套路 设置性能检测函数(函数):
    """为所有从 线程化 模块开始的线程设置性能检测函数.
    
    在每个线程的 运行() 方法被调用前, 函数 会被传递给 系统.设置性能检测().
    """
    setprofile(函数)

套路 设置追踪函数(函数):
    """为所有从 线程化 模块开始的线程设置追踪函数.

    在每个线程的 运行() 方法被调用前, 函数 会被传递给 系统.设置追踪().
    """
    settrace(函数)

类 〇锁:
    """实现原始锁对象的类. 一旦一个线程获得一个锁, 就会阻塞随后尝试获得锁的线程,
    直到它被释放; 任何线程都可以释放它.
    """
    套路 __init__(分身):
        分身._锁 = Lock()

    套路 获取(分身, 阻塞=真, 超时=-1):
        """可以阻塞或非阻塞地获得锁.
        """
        返回 分身._锁.acquire(blocking=阻塞, timeout=超时)

    套路 释放(分身):
        """释放该锁, 以便另一个被阻塞的等待该锁的线程可以获得该锁. 
        该锁必须处于锁定状态, 但无需由解锁它的线程锁定.
        """
        分身._锁.release()

    套路 已锁定(分身):
        """若该锁处于锁定状态则返回 真.
        """
        返回 分身._锁.locked()

# 〇锁 = Lock
从 threading 导入 _RLock

套路 〇重入锁(*参数, **关键词参数):
    """返回一个新重入锁的工厂函数.

    重入锁必须由获取它的线程释放. 一旦线程获得了重入锁, 
    同一个线程再次获取它将不阻塞; 线程必须在每次获取它时释放一次.
    """
    返回 _RLock(*参数, **关键词参数)

类 〇线程(Thread):
    """代表一个控制线程的类.

    此类可以安全且有限度地继承. 指定活动的方法有两种:
    将一个可调用对象传递给构造函数, 或者在子类中重载 运行() 方法.
    """
    套路 __init__(分身, 组=None, 目标=None, 名称=None,
                 参数々=(), 关键词参数々=None, *, 守护=None):
        """调用这个构造函数时, 必须带有关键词参数. 参数如下:

        *组* 应为 空, 供未来扩展使用.

        *目标* 为由 *运行()* 方法调用的对象. 默认为空.

        *名称* 为线程名称. 默认情况下, 由 "线程-N" 格式构成一个唯一名称,
        其中 N 是较小的十进制数.

        *参数々* 是用于调用目标函数的参数元组. 默认为 ().
        
        *关键词参数々* 是用于调用目标函数的关键词参数字典. 默认为 {}.

        如果子类型重载了构造函数, 务必确保在做任何事之前, 
        先发起调用基类构造器 (〇线程.__init__()).
        """
        super().__init__(group=组, target=目标, name=名称,
                 args=参数々, kwargs=关键词参数々, daemon=守护)
        分身.开始 = 分身.start
        # 分身.运行 = 分身.run
        分身.标识 = 分身.ident
        分身.原生id = 分身.native_id
        分身.是活着 = 分身.is_alive


    def __repr__(self):
        assert self._initialized, "未调用 〇线程.__init__()"
        status = "初始"
        if self._started.is_set():
            status = "已开始"
        self.is_alive() # easy way to get ._is_stopped set when appropriate
        if self._is_stopped:
            status = "已停止"
        if self._daemonic:
            status += " 守护"
        if self._ident is not None:
            status += " %s" % self._ident
        return "<%s(%s, %s)>" % (self.__class__.__name__, self._name, status)

    套路 run(分身):
        分身.运行()

    套路 运行(分身):
        try:
            if 分身._target:
                分身._target(*分身._args, **分身._kwargs)
        finally:
            # Avoid a refcycle if the thread is running a function with
            # an argument that has a member that points to the thread.
            del 分身._target, 分身._args, 分身._kwargs

    套路 并入(分身, 超时=空):
        """等待，直到线程终结.

        这会阻塞调用此方法的线程, 直到被调用其 并入() 方法的线程终结 -- 不管是正常终结
        还是抛出未处理异常 -- 或者直到发生超时, 超时 参数是可选的.

        当 超时 参数存在且不是 空 时, 它应该是一个浮点数, 指定操作超时时间, 以秒为单位 (可以有小数).
        因为 并入() 总是返回 空, 所以一定要在 并入() 后调用 是活着() 才能判断是否发生超时 -- 如果
        线程仍然存活, 则 并入() 超时.

        当 超时 参数不存在或者为 空 时, 此操作会阻塞直到线程终结.

        一个线程可以 并入() 多次.

        如果尝试并入当前线程 (这会导致死锁), 并入() 会引起 爻运行时错误.
        如果尝试 并入() 一个尚未开始的线程, 也会抛出相同的异常.
        """
        分身.join(timeout=超时)

    @property
    套路 名称(分身):
        """字符串, 仅用于标识目的.

        没有语义. 多个线程可以有相同名称. 
        初始名称由构造函数设置.
        """
        返回 分身.name

    @名称.setter
    套路 名称(分身, 名称):
        分身.name = str(名称)

    @property
    def 守护(分身):
        """表示这个线程是否为守护线程的布尔值.

        一定要在调用 开始() 前设置好, 不然会抛出 爻运行时错误.
        初始值继承于创建线程; 主线程不是守护线程, 因此主线程创建的所有线程默认都是 守护 = 假.

        当没有存活的非守护线程时, 整个 Python 程序才会退出.

        """
        返回 分身.daemon

    @守护.setter
    def 守护(分身, 守护性):
        分身.daemon = 守护性


类 〇条件(Condition):
    """实现条件变量对象的类.

    条件变量允许一个或多个线程等待, 直至得到其他线程的通知.

    如果给出了非空的 锁 参数, 则它必须为 〇锁 或 〇重入锁 对象, 
    并且它将被用作底层锁. 否则, 将会创建新的 〇重入锁 对象并将其用作底层锁.
    """

    套路 __init__(分身, 锁=空):
        super().__init__(lock=锁)
        分身.通知 = 分身.notify
        分身.通知全部 = 分身.notify_all
        分身.释放 = 分身.release

    套路 获取(分身, 阻塞=真, 超时=-1):
        返回 分身.acquire(blocking=阻塞, timeout=超时)

    套路 等候(分身, 超时=空):
        """等待直到被通知或发生超时.

        如果线程在调用此方法时没有获得锁, 将会引发 爻运行时错误.

        此方法释放底层锁, 然后阻塞, 直到在另外一个线程中调用同一条件变量的 
        通知() 或 通知全部() 唤醒它, 或者直到超时 (可选参数) 发生. 
        一旦被唤醒或超时, 它重新获得锁并返回.

        当 超时 参数存在且不是 空 时, 它应该是一个浮点数, 代表操作的超时时间, 
        以秒为单位 (可以为小数).

        当底层锁是 〇重入锁 对象时, 不使用其 释放() 方法释放锁, 因为当它被递归多次获取时, 
        实际上可能无法解锁. 应使用 〇重入锁 的内部接口来解锁, 即使多次递归获取它也能解锁. 
        然后, 当重新获取锁时, 使用另一个内部接口来恢复递归级别.

        返回 真, 除非 超时 过期, 这种情况下返回 假.
        """
        返回 分身.wait(timeout=超时)

    套路 等候条件(分身, 判定, 超时=空):
        """等待直到条件计算为真.

        判定 应该是一个可调用对象且其结果可被解释为一个布尔值.
        可以提供 超时 参数给出最大等待时间.
        """
        返回 分身.wait_for(判定, timeout=超时)


类 〇信号量(Semaphore):
    """该类实现信号量对象.

    信号量对象管理一个原子性的计数器, 代表 释放() 方法的调用次数减去 获取() 方法的调用次数
    再加上一个初始值. 如果需要, 获取() 方法将会阻塞直到可以返回而不会使得计数器变成负数.
    在没有显式给出 值 参数的值时, 默认为 1.
    """
    套路 __init__(分身, 值=1):
        super().__init__(value=值)
        分身.释放 = 分身.release

    套路 获取(分身, 阻塞=真, 超时=空):
        """获取一个信号量, 内部计数器减 1.

        不带参数调用时: 如果在进入时内部计数器的值大于 0, 则将其减 1 并立即返回 真; 
        如果在进入时内部计数器的值为 0, 则将会阻塞, 直到其他线程调用 释放() 使其
        计数器值大于 0. 这是通过适当的联锁机制完成的, 如有多个 获取() 调用被阻塞,
        释放() 只会唤醒其中一个. 挑选可能是随机的, 因此被阻塞线程的唤醒次序是不确定的. 
        这种情况下没有返回值.

        当发起调用时 阻塞 设为 真, 则执行与无参数调用时一样的操作, 然后返回 真.

        当发起调用时 阻塞 设为 假, 则不进行阻塞. 如果一个无参数调用将要阻塞, 
        则立即返回 假; 在其他情况下, 执行与无参数调用时一样的操作, 然后返回 真.

        当发起调用时 超时 不为 空, 它将阻塞最多 超时 秒. 
        如果获取请求在此时段时未能成功完成, 则将返回 假, 否则返回 真.
        """
        返回 分身.acquire(blocking=阻塞, timeout=超时)


类 〇有界信号量(BoundedSemaphore):
    """该类实现信号量对象.

    信号量对象管理一个原子性的计数器, 代表 释放() 方法的调用次数减去 获取() 方法的调用次数
    再加上一个初始值. 如果需要, 获取() 方法将会阻塞直到可以返回而不会使得计数器变成负数.
    在没有显式给出 值 参数的值时, 默认为 1.
    """
    套路 __init__(分身, 值=1):
        super().__init__(value=值)
        分身.释放 = 分身.release


〇事件 = Event

类 〇栅栏(Barrier):
    """创建一个栅栏对象, 初始化为 '线程数' 个线程.

    '动作' 是一个可调用对象, 如有提供, 则在所有线程均已进入栅栏且就要全部释放之前
    由其中一个线程调用. 如果提供了 '超时' 参数, 它将用作所有随后 '等候()' 调用的默认值.
    """
    套路 __init__(分身, 线程数, 动作=空, 超时=空):
        super().__init__(线程数, action=动作, timeout=超时)
        分身.重置 = 分身.reset
        分身.中止 = 分身.abort
        分身.线程数 = 分身.parties
        分身.等候线程数 = 分身.n_waiting
        分身.破损 = 分身.broken

    套路 等候(分身, 超时=空):
        """等待冲出栅栏.

        当指定数量的线程开始等待时, 它们同时被唤醒. 如果为栅栏对象提供了一个 '动作', 
        其中一个线程将在返回之前执行该回调函数. 返回从 0 到 '线程数-1' 的索引号.
        """
        返回 分身.wait(timeout=超时)

爻栅栏破损错误 = BrokenBarrierError

异常钩子 = excepthook
异常钩子参数々 = ExceptHookArgs


类 〇定时器(Timer):
    """经过指定秒数后调用一个函数:

            定时器 = 〇定时器(30.0, 函数, 参数々=空, 关键词参数々=空)
            定时器.开始()
            定时器.取消()     # 如果定时器仍在等待, 则停止其操作
    """
    套路 __init__(分身, 等待时间, 函数, 参数々=None, 关键词参数々=None):
        super().__init__(等待时间, 函数, args=参数々, kwargs=关键词参数々)
        分身.取消 = 分身.cancel
        分身.运行 = 分身.run

套路 枚举() -> List[〇线程]:
    """返回当前存活的所有线程对象的列表.

    该列表包含守护线程, 当前线程() 创建的虚拟线程对象和主线程.
    它不包含已终结的线程和尚未开始的线程.
    """
    返回 enumerate()

当前线程 = current_thread
活动线程数 = active_count
# 枚举 = enumerate
栈大小 = stack_size
主线程 = main_thread
〇本地 = local
